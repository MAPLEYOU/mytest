# 刷题记录

[242.有效字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

思路一：使用哈希表存储

```cpp
class Solution {

public:

  bool isAnagram(string s, string t) {

​    map<char,int> myMap;  //新建一个map存键值



​    //将s中有的键存入map并且++

​    for(char c:s){

​      myMap[c]++;

​    }



​    //t中发现一样的就--，不一样就插入

​    for(char c:t){

​      if(myMap[c]>0){

​        myMap[c]--;

​      }else{

​        myMap[c]++;

​      }

​    }

​    //如果找到非0则返回假

​    for(int i=0;i<myMap.size();i++){

​      if(myMap[i]>0){

​        return false;

​      }

​    }

​    return true;

  }

};
```

思路二：使用sort排序

1：首先判断两个数长度是否一样，不一样直接返回假

2：再对两个字符串用sort排序

3：最后return s==t，如果相等返回为真，如果不相等返回为假

![image-20210907223141779](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20210907223141779.png)

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.size()!=t.size()) return false;
        sort(s.begin(),s.end());
        sort(t.begin(),t.end());
        return s==t;
    }
};
```



#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

思路一：递归法

![image-20210907231958142](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20210907231958142.png)

1:确定递归函数的参数和返回值

由于要比较的是根节点两个子树是否相互反转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。

2：确定终止条件

要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚，否则后面比较数值的时候就会操作空指针了。

节点为空的情况有：

- 左节点为空，右节点不为空，不对称，return false

- 左不为空，右为空，不对称，return false

- 左右都为空，对称，返回true

  此时已经排除了节点为空的情况，那么剩下的就是左右节点不为空

  - 左右节点都不为空，比较节点数值

3.确定单层递归的逻辑

此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

- 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
- 比较内测是否对称，传入左节点的右孩子，右节点的左孩子。
- 如果左右都对称就返回true ，有一侧不对称就返回false 。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    //
    bool compare(TreeNode* left,TreeNode* right){
        //第一步排除空节点情况
        if(left==nullptr&&right!=nullptr) return false;  //不对称
        if(left!=nullptr&&right==nullptr) return false; //不对称
        if(left==nullptr&&right==nullptr) return true;  //对称
        if(left->val!=right->val)         return false;  //不相等返回为假

        //接下来处理相等情况
        bool outside = compare(left->left,right->right);  //先处理外子节点
        bool inside = compare(left->right, right->left);  //再处理内子节点
        bool res = outside&&inside;
        return res;
    }

    bool isSymmetric(TreeNode* root) {
       if(root == nullptr) return true;
       return compare(root->left,root->right);
    }
};
```

9.8

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

思路一：回溯算法

```cpp
class Solution {
public:

    vector<vector<int>> result;               //用来返回所有符合条件结果的集合
    vector<int> path;                         //用来返回符合条件的结果
    //回溯函数
    //回溯三部曲：1:确定回溯函数返回与输入参数(返回参数通常是void，也有极少例外)
    void backtracking(int n,int k,int startIndex){
    //回溯三部曲：2：确定终止条件，当搜索到目标组合，结果压入集合中并终止
        if(path.size()==k){
            result.push_back(path);
            return;
        }
    //回溯三部曲：3：开始单层逻辑
    for(int i=startIndex;i<=n;i++){
        path.push_back(i);            //处理节点
        backtracking(n, k, i+1);      //递归
        path.pop_back();              //回溯撤销处理节点
    }

    }
    vector<vector<int>> combine(int n, int k) {
        result.clear();
        path.clear();             //安全保护
        backtracking(n,k,1);      //回溯开始
        return result;
    }
};
```

9.9

#### [面试题 01.01. 判定字符是否唯一](https://leetcode-cn.com/problems/is-unique-lcci/)

关于细节：

如果我是面试官，我会希望看到什么？

可能有点偏题，毕竟这里主要就是做题的地方。。

如果我是面试官，会考虑主要考察什么，就我的工作经验看，大多数主要是招聘工程师的，面试者如果什么问题都没有，直接写个二重循环搞定，会首先给个50分，如果能写点判断字符串是否为null的，60分。

直接上手什么bitset，什么位运算的，我会先问他，题目中有没有交代字符串的字符一定是26个英文字母？如果是unicode环境，你是不是要准备2^16/8个字节的空间？在实际项目中，风险可控，结果可期更重要，绝大多数时候不在乎那点时间和资源。

所以我期望面试者不要急于解答，我希望他先问我问题：

1. 字符串的字符范围，如果我告诉他，26个小写英文字母，那可能一开头直接判断如果字符长度>26, 直接返回False，做到这一点的，80分
2. 如果我告诉他ascii字符集，然后他的代码里有边界检查，并且针对不同的范围有不同的侧重点，比如说ascii字符集，那也就是128个可能性，16个字节的位运算比较好
3. 如果我告诉他是unicode，没有字符范围，老老实实排序再判断是比较符合我对工程师的要求的，因为算法性能稳定，没有额外资源要求，一眼看出没什么不可预见的风险，100分。

就是说，有些东西，没想到或者一时没想到根本不是问题，日常工作中稍微提示一下即可，但是缜密的思维对于程序员来说更重要。

思路一：这个用map数据结构，不符合题目要求不适用额外数据结构的要求

```cpp
class Solution {
public:
    bool isUnique(string astr) {
        map<char,int> myMap;
        for(char c:astr){
            if(myMap[c]==0){
                myMap[c] = 1;
            }else {
                return false;
            }
        }
        return true;
    }
};

```

思路二：先sort排序，再判断前后两个是否相同。

```cpp
class Solution {
public:
    bool isUnique(string astr) {
        sort(astr.begin(),astr.end());
        for(int i=1;i<astr.size();i++){
            if(astr[i-1]==astr[i]){
                return false;
            }
        }
        return true;
    }
};
```



#### [面试题 01.02. 判定是否互为字符重排](https://leetcode-cn.com/problems/check-permutation-lcci/)

思路一：先排序，再对比是否相等(有点抖机灵)

```cpp
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        sort(s1.begin(),s1.end());
        sort(s2.begin(),s2.end());
        return s1==s2;
    }
};
```



#### [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

思路一：用map

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        map<int,int> myMap;
        for(int n : nums){
            if(myMap[n]==0){
                myMap[n]=1;
            }else {
                return true;
            }
        }
        return false;
    }
};
```

使用unordered_set也是哈希表。

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
      unordered_set<int> myset;
      for(int n:nums){
          if(myset.find(n)!=myset.end()){
              return true;
          }else {
              myset.insert(n);
          }
      }
      return false;
    }
};
```



思路二：直接排序对比，效率高，内存消耗比较低

![image-20210909103226849](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20210909103226849.png)

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        for(int i=1;i<nums.size();i++){
            if(nums[i-1]==nums[i]){
                return true;
            }
        }
        return false;
    }
};
```



#### [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

思路一：直接用map没有考虑到后面的1，1情况，这种就会错误，回头再优化

![image-20210909121856361](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20210909121856361.png)

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int,int> myMap;
        for(int i=0;i<nums.size();i++){
            if(myMap[nums[i]]==0){
               myMap[nums[i]] = i+1;
            }else {
                if((i+1-myMap[nums[i]])<=k){
                    return true;
                }
            }
        }
        return false;
    }
};
```

9.10

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```cpp
class MyQueue {
public:
    stack<int> inStack;           //输入栈
    stack<int> outStack;          //输出栈
    /** Initialize your data structure here. */
    MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        inStack.push(x);     //压入输入的栈中
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        //如果输出栈为空就把输入的全部放到输出栈中
        if(outStack.empty()){  
            while(!inStack.empty()){
                int res = inStack.top();
                inStack.pop();
                outStack.push(res);
            }
        }

        int res = outStack.top();
        outStack.pop();
        return res;
    }
    
    /** Get the front element. */
    int peek() {
            int res = this->pop();
            outStack.push(res);
            return res;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return inStack.empty()&&outStack.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

思路一：使用set，如果不包含就插入，如果包含就返回真

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        set<ListNode*> mySet;
        while(head!=nullptr){
            if(mySet.find(head) !=  mySet.end()){
                return true;
            }else {
                mySet.insert(head);
                head = head->next;
            }
        }
        return false;
    }
};
```



#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

思路：归并排序，一长一短，肯定会有一个先放完，放完后把另一个拷贝过去即可。

为了避免覆盖所以从最后开始向前放最大的元素

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {

        //利用归并排序的思想
         int index1 = m-1, index2 = n-1;
         int size_nums = nums1.size()-1;

        //先整体进行排序
         while(index1>=0&&index2>=0){
             if(nums1[index1]<nums2[index2]){
                 nums1[size_nums] = nums2[index2];
                 index2--;
                 size_nums--;
             }else {
                 nums1[size_nums] = nums1[index1];
                 index1--;
                 size_nums--;
             }
         }

        //考虑边界情况
         while(index1>=0){
            nums1[size_nums] = nums1[index1];
            index1--;
            size_nums--;
         }

         //当第二个索引没有到0，说明第二个还有数没有完全到1里面
          while(index2>=0){
            nums1[size_nums] = nums2[index2];
            index2--;
            size_nums--;
         }

    }
};
```

#### [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)

思路：二分查找

```cpp
class Solution {
public:
    int mySqrt(int x) {
        //1:考虑特殊情况
        if(x<2) return x;
        //2:初始化边界
        int low = 2,high = x/2;   //平方跟的最大在它的一半以内，缩短时间
        while(low<=high) {
            int middle = low + (high-low)/2;  //防止溢出情况
            //防止溢出使用除法
            if(middle == x/middle) return middle; 
            else if (middle < x/middle) low = middle +1;
            else high = middle -1;
        }
        return high;
    }
};
```

#### [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

思路：二分法

```cpp
/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is lower than the guess number
 *			      1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */

class Solution {
public:
    int guessNumber(int n) {
        int low = 0,high = n;
        while(low<=high){
            int middle = low + (high-low)/2;
            int flag = guess(middle);
            if(flag==0) return middle;
            else if(flag== 1) low = middle+1;
            else if(flag== -1)high = middle-1;
        }
        return high;
    }
};
```



#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

思路：使用一个头节点，然后用cur指针指向头

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(0);  //新建一个头节点
        dummy->next = head; //下一个指针指向链表头
        ListNode* cur = dummy;
        while(cur->next!=nullptr&&cur->next->next!=nullptr){
           
            ListNode* next = cur->next;
            ListNode* nextNext = cur->next->next;
            ListNode* next2Next = cur->next->next->next;

            cur->next = nextNext;        //步骤一
            cur->next->next = next;      //步骤二
            cur->next->next->next = next2Next; //步骤三
            
            cur = cur->next->next;    //移动当前链表指针到下两个
        }

        return dummy->next;
    }
};
```



#### [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

思路一：先使用vector容器存下每一位的数据，在判断容器里面首尾是否相等

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if(x<0) return false;

        vector<int> data;
        while(x!=0){
            int temp = x%10;
            x = x/10;
            data.push_back(temp);
        }

       int start = 0,end=data.size()-1;
       while(start<end){
           if(data[start]!=data[end]){
               return false;
           }
           start++;
           end--;
       }
        return true;
    }
};
```



#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

思路一：异或，当不同的数异或肯定会保留下来，相同的数异或之后，就会相互抵消。

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int i=0;i<nums.size();i++){
            res = res ^nums[i];
        }
        return res;
    }
};
```

思路二：哈希表,需要增加额外的空间复杂度o(n)

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        map<int,int> mymap;
        for(int i=0;i<nums.size();i++){
            mymap[nums[i]]++;
        }
        
        for(map<int,int>::iterator it = mymap.begin();it!=mymap.end();it++){
            if(it->second==1){
                return it->first;
            }
        }
        return res;
    }
};
```

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

思路：滑动窗口

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.empty()) return 0;
        int maxSize = 0;
        int left = 0;
        unordered_set<char> lookup;
        for(int i=0;i<s.size();i++){
            while(lookup.find(s[i])!=lookup.end()){
                lookup.erase(s[left]);
                left++;
           }
           lookup.insert(s[i]);
           maxSize = max(maxSize,i-left+1);
    }
    return maxSize;
    }
};
```

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

思路一：使用set用到了额外的内存，没有达到题目要求

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode*> myset;
        while(headA!=nullptr){
            myset.insert(headA);
            headA = headA->next;
        }
        while(headB!=nullptr){
            if(myset.find(headB)!=myset.end()){
                return headB;
            }else {
                headB = headB->next;
            }
        }
        return nullptr;
    }
};
```

思路二：

```c
/**定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)
两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度
**/
// 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null
```



```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *A = headA, *B = headB;
         /**
        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)
        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度
        **/
         // 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null
        while(A!=B){
            A = A!=nullptr ? A->next : headB;
            B = B!=nullptr ? B->next : headA;
        }
        return A;
    }
};
```



#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

思路一：暴力法

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        vector<int> recVec;
        int res = INT32_MAX;  //用来存放最终结果的
        int sum=0;   //子序列数值之和
        int subLength = 0;   //子序列长度
        for(int i=0;i<nums.size();i++){ 
            sum = 0;
            for(int j=i;j<nums.size();j++){
                sum +=nums[j];   
                if(sum>=target){
                    subLength = j-i+1;
                    res = res<subLength ? res :  subLength;
                    break;
                }
            }
        }
        return res = res == INT32_MAX ? 0 : res;
    }
};
```

思路二：滑动窗口

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        vector<int> recVec;
        int res = INT32_MAX;  //用来存放最终结果的
        int sum=0;   //子序列数值之和
        int subLength = 0;   //子序列长度
        int i = 0;   //滑动窗口的起始位置
        for(int j=0;j<nums.size();j++){ 
            sum += nums[j];
            while(sum>=target){
                subLength = j-i+1;
                res = res < subLength ? res : subLength;
                sum -=nums[i++];
            }
        }
        return res = res == INT32_MAX ? 0 : res;
    }
};
```

#### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

解题思路：
这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小

首先设定上下左右边界
其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界
判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案
若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理
不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        int u = 0;                 //定义上边界
        int d = matrix.size()-1;   //定义下边界
        int l = 0;                 //定义左边界
        int r = matrix[0].size()-1;//定义右边界
        while(true){
            for(int i=l;i<=r;i++) res.push_back(matrix[u][i]);  //向右
            if(++u>d) break;      //重新定义上边界，第一行走完了

            for(int i=u;i<=d;i++) res.push_back(matrix[i][r]);  //向下移动
            if(--r<l) break;//重新定义右边边界

            for(int i=r;i>=l;i--) res.push_back(matrix[d][i]);  //向左移动
            if(--d<u) break;//重新定义下边界

            for(int i=d;i>=u;i--) res.push_back(matrix[i][l]);  //向上移动
            if(++l>r) break;//重新定义左边界
        }

        return res;
    }
};
```



# 剑指offer

#### [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

思路一：递归会超出时间限制

```cpp
class Solution {
public:
    int fib(int n) {
        if(n<2) return n;
        return fib(n-1) + fib(n-2);
    }
};
```

思路二：动态规划

```cpp
class Solution {
public:
    int fib(int n) {
        if(n<2) return n;
        vector<int> dp(n+1);  //dp[i],为值为i时候结果为dp[i]
        dp[0] = 0;
        dp[1] = 1;
        for(int i=2;i<n+1;i++){
            dp[i] = dp[i-1] +dp[i-2];
            dp[i] = dp[i]%1000000007;
        }
       return dp[n];
    }
};
```

# 

#### [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)（*）

思路一：暴力解法，两层for循环查找

时间复杂度为:O(nm)

空间复杂度为:O(1)

```cpp
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        if(matrix.empty()) return false;
        int n = matrix.size();      //行数
        int m = matrix[0].size();   //列数
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(matrix[i][j]==target){
                    return true;
                }
            }
        }
        return false;
    }
};
```

思路二：如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target 。

![Picture1.png](https://pic.leetcode-cn.com/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png)

“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:

若 flag > target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。
若 flag < target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。
算法流程：
从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比：

- 当 matrix[i][j]> target 时，执行 i-- ，即消去第 i 行元素；
- 当 matrix[i][j] < target 时，执行 j++ ，即消去第 j 列元素；
- 当 matrix[i][j] = target 时，返回 truetrue ，代表找到目标值

2.若行索引或列索引越界，则代表矩阵中无目标值，返回 false 。

- 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。

```cpp
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        if(matrix.empty()) return false;
        //从左下角开始往上搜索
        int i = matrix.size()-1;
        int j = 0;
        while(i>=0&&j<matrix[0].size()){  //循环搜索
            if(matrix[i][j]>target){
                i--;
            }else if(matrix[i][j]<target){
                j++;
            }else {
                return true;
            }
        }
        return false;
    }
};
```

```cpp
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        if(matrix.empty()) return false;
        //从左上角开始往下搜索
        int i = 0;
        int j = matrix[0].size()-1;
        while(i<matrix.size()&&j>=0){  //循环搜索
            if(matrix[i][j]<target){
                i++;
            }else if(matrix[i][j]>target){
                j--;
            }else {
                return true;
            }
        }
        return false;
    }
};
```



#### [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

思路一：递归，会超出时间限制

```cpp
class Solution {
public:
    int numWays(int n) {
        if(n==0||n==1) return 1;
        if(n==2) return 2;
        int res = numWays(n-1)+numWays(n-2);
        return res%1000000007;
    }
};
```

思路2：动态规划

```cpp
class Solution {
public:
    int numWays(int n) {
        if(n<=1) return 1;

        vector<int> dp(n+1);
        dp[1] = 1;
        dp[2] = 2;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1] + dp[i-2];
            dp[i] = dp[i]%1000000007;
        }
        return dp[n];
    }
};
```

#### [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)（*）

思路一：先排序，返回第一个数组值

```cpp
class Solution {
public:
    int minArray(vector<int>& numbers) {
        sort(numbers.begin(),numbers.end());
        return numbers[0];
    }
};
```

思路二：暴力法

- 从下标为0的元素开始便利
- 每次进行比较，如果当前元素比相邻的下一个元素大，则对应的下一个元素即为最小值
- 如果查到最后一个元素都没有这两种情况，则下标为0的元素为最小元素

```cpp
class Solution {
public:
    int minArray(vector<int>& numbers) {
        for(int i=0;i<numbers.size()-1;i++){
            if(numbers[i]>numbers[i+1]){
                return numbers[i+1];
            }
        }
        return numbers[0];
    }
};
```

思路3：二分查找法

- 一般二分查找要求：
- 1：顺序存储
- 2：元素有序

原因：

- 1：可以通过下标即可得到关键字

- 2：任取一个关键字的值即可确定所寻找关键字是在它前面还是后面

```cpp
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int low = 0;
        int high = numbers.size() - 1;
        while (low < high) {
            int pivot = low + (high - low) / 2;
            if (numbers[pivot] < numbers[high]) {
                high = pivot;
            }
            else if (nsumbers[pivot] > numbers[high]) {
                low = pivot + 1;
            }
            else {
                high -= 1;
            }
        }
        return numbers[low];
    }
};
```





#### [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

思路一：DFS+回溯

DFS 解析：
递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。
终止条件：
返回 false ： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。
返回 true ： k = len(word) - 1 ，即字符串 word 已全部匹配。
递推工作：
标记当前矩阵元素： 将 board[i][j] 修改为 空字符 '' ，代表此元素已访问过，防止之后搜索时重复访问。
搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。
还原当前矩阵元素： 将 board[i][j] 元素还原至初始值，即 word[k] 。
返回值： 返回布尔量 res ，代表是否搜索到目标字符串。

作者：jyd
链接：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```cpp
class Solution {
public:
    int rows,cols;   //为了减少dfs输入参数的
    bool exist(vector<vector<char>>& board, string word) {
         rows=board.size();            //行
         cols=board[0].size();        //列
        //两层for循环行列便利找
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                //从某行某列，字符串第0号位置开始遍历寻找，如果找到返回真
                if(dfs(board,word,i,j,0)) return true;
            }
        }
        return false;
    }

     //确定dfs的输入参数,i:行,j:列,k：找到字符串中第几个
    bool dfs(vector<vector<char>>& board,string word,int i,int j,int k){
          //首先确定回溯终止条件
          //当超出矩阵的左右边界或者找到的不是想要的字符返回假
          if(i>=rows||i<0||j>=cols||j<0||board[i][j]!=word[k]) return false;
          if(k==word.size()-1) return true;   //当找到的字符是字符串最后一个字符返回真
          board[i][j] = '\0';     //已经找到过的地方置为0,标记减枝
          bool res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i-1, j , k + 1) 
                    ||dfs(board, word, i, j+1, k + 1)|| dfs(board, word, i , j-1, k + 1);
          board[i][j] = word[k];  //当需要进行回溯时候就返回回撤
          return res;
    }

};
```



#### [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

思路一：翻转

1：用vector存从头到尾的每个节点值

2：返回时候用reverse翻转一下

时间复杂度：O(n)

空间复杂度：O(n)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        vector<int>  vec;
        while(head!=nullptr){
            vec.push_back(head->val);
            head = head->next;
        }
        reverse(vec.begin(), vec.end());
        return vec;
    }
};
```



思路二：递归

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> reversePrint(ListNode* head) {
        if(head==nullptr) return res;
        reversePrint(head->next);//递归到最后一层
        res.push_back(head->val);//开始从最后压入值到容器
        return res;
    }
};
```



思路三：使用辅助栈

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        stack<ListNode*> stk;
        vector<int> res;
        while(head!=nullptr){
            stk.push(head);
            head = head->next;
        }
        while(!stk.empty()){
            int tempnum = stk.top()->val;
            stk.pop();
            res.push_back(tempnum);
        }
        return res;
    }
};
```

#### [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

思路一：双指针法

1.设置dummy为头结点，放置于新链表之前，最后返回的就是dummy.next；设置cur为当前节点，从dummy开始
2.当两个链表都非空时进入循环，令新链表的下一个节点cur.next为val更小的节点，相应的链表节点后移一位
3.每次循环记得cur也要后移一位
4.如果循环结束后还有链表非空，cur指向非空链表
5.返回dummy.next

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
       ListNode* res = new ListNode(0);   //新建一个头节点
       ListNode* cur = res;               //定义一个当前指针
       while(l1!=nullptr&&l2!=nullptr){
           if(l1->val<=l2->val){
               cur->next = l1;
               l1 = l1->next;
           }else {
               cur->next = l2;
               l2 = l2->next;
           }
           cur = cur->next;
       }
      /* if(l1==nullptr){
           cur->next = l2;
       }else if(l2==nullptr){
           cur->next = l1;
       }*/
        cur->next = l1!=nullptr? l1:l2;
       return res->next;
    }
};
```

思路二：递归法

1. 特判：如果有一个链表为空，返回另一个链表
2. 如果l1节点值比l2小，下一个节点应该是l1，应该return l1，在return之前，指定l1的下一个节点应该是l1.next和l2俩链表的合并后的头结点
3. 如果l1节点值比l2大，下一个节点应该是l2，应该return l2，在return之前，指定l2的下一个节点应该是l1和l2.next俩链表的合并后的头结点

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1==nullptr) return l2;
        if(l2==nullptr) return l1;

        if(l1->val<=l2->val){
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }else{
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }

       
    }
};
```

#### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

思路一:递归

从根节点开始，递归的对树进行遍历，并从叶子节点开始翻转，得到镜像。如果当前遍历到的节点root的左右两棵子树都已经翻转得到了镜像，那么我们只需要交换两棵子树的位置，即可得到以root为跟节点的整颗子树的镜像。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        //首先确定递归的截至条件，当为空时候直接返回结束递归
        if(root==nullptr) return root;

        //不为空时候，先左边深度往下递归寻找，再右边寻找
        if(root->left!=nullptr) mirrorTree(root->left);
        if(root->right!=nullptr) mirrorTree(root->right);

        //找到最后一层，左右节点进行交换
        TreeNode* tempNode = root->left;
        root->left = root->right;
        root->right = tempNode;

        //返回交换后的结果
        return root;
    }
};
```

递归部分优化代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        //首先确定递归的截至条件，当为空时候直接返回结束递归
        if(root==nullptr) return nullptr;

        //不为空时候，先左边深度往下递归寻找，再右边寻找
        // if(root->left!=nullptr) mirrorTree(root->left);
        // if(root->right!=nullptr) mirrorTree(root->right);
        TreeNode* left = mirrorTree(root->left);
        TreeNode* right= mirrorTree(root->right);

        //找到最后一层，左右节点进行交换
        root->left  = right;
        root->right = left;

        //返回交换后的结果
        return root;
    }
};
```

#### [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

思路一：利用dfs深度优先搜索

- 首先确定递归搜索的终止条件

  1：i，j超出范围

  2：数位之和大于k

  3：(i,j)被访问过

- 接下来进行dfs

  可以进行一个dfs减枝优化，由于从0，0开始，则只要判断右边和下边即可，因为左和上一定会在搜索过程中被包括

```cpp
class Solution {
public:

    // set<vector<int>> visited;   //用来存访问过的数
    //获取行列坐标之和
    int getSum(int i,int j){
        int resall=0;
        while(i){         //当为0时候退出循环
            resall += i%10;   //求最后一位余数
            i/=10;        //去除最后一位
        }
        while(j){
            resall += j%10;   //求最后一位余数
            j/=10;        //去除最后一位
        }
        return resall;
    }

    int dfs(int i,int j,int m,int n,int k,vector<vector<bool>>& flag){       //写一个深度优先遍历
    //    vector<int> temp={i,j};
        //确定dfs终止条件
        //1:i,j超范围 i>=m||j>=n
        //2:数位和大于k getSum(i,j)>k
        //3:i,j的坐标被访问过 visited.find(temp)!=visited.end()
        if(i>=m||j>=n||getSum(i,j)>k||flag[i][j]){return 0;}
       // visited.insert(temp);
        flag[i][j] = true;
        //如果从(0,0)开始不用考虑向上移动的,没有回溯
        int res = 1 + dfs(i+1,j,m,n,k,flag) +dfs(i,j+1,m,n,k,flag);
        return res;
    }

    int movingCount(int m, int n, int k) {
        vector<vector<bool>> flag(m, vector<bool>(n, false));
        int res=0;
        res = dfs(0,0,m,n,k,flag);
        return res;
    }
};
```



#### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

对称二叉树定义：对于树中任意两个对称节点L和R，一定有：

- L.val == R.val：这两个对称节点值相等
- L.left.val == R.right.val：即L的左子节点和R的右子节点对称；
- L.right.val == R.left.val：即L的右子节点和R的左子节点对称

![Picture1.png](https://pic.leetcode-cn.com/ebf894b723530a89cc9a1fe099f36c57c584d4987b080f625b33e228c0a02bec-Picture1.png)

接下来递归处理：

特例：若根节点root为空，则直接返回true

返回值：即 `recur(root.left, root.right)`

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool recur(TreeNode* L,TreeNode* R){
        if(L==nullptr&&R==nullptr) return true;
        if(L==nullptr||R==nullptr||L->val!=R->val) return false;  //确定终止条件
        bool res = recur(L->left,R->right)&&recur(L->right,R->left);
        return res;
    }
    bool isSymmetric(TreeNode* root) {
       if(root==nullptr) return true;
        return recur(root->left,root->right);
    }
};
```



#### [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

思路一：使用快慢双指针

1: i找偶数找到了，继续往下执行，找不到i++

2：j找奇数，找到了继续往下执行，找不到j--

3：最后交换

```cpp
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        //双指针,i找偶数,j找奇数
        int i=0,j=nums.size()-1;
        while(i<j){
            //当前面一半，i是奇数i继续++，当i是偶数往后执行
            if(nums[i]%2==1) {
                i++;
                continue;
            }
            //当后面一半，i是偶数j--;当找到奇数往后执行
            if(nums[j]%2== 0){
                j--;
                continue;
            } 
            //奇数偶数都找到了交换
            swap(nums[i], nums[j]);
        }
        return nums;
    }
};
```



#### [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

思路一：n>>1一直右移动，如果为1则res++

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        //定义一个res用来返回值
        int res=0;
        //当n不为0时候一直进入循环
        while(n){
            if((n&1)==1){    //如果最后一位是1则res++
                res++;
            }
            n= n>>1;   //然后n往右移动1位
        }
        return res;
    }
};
```

#### [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

思路一：最简单的思路

1:转换成字符串，获得最大的数

2：一直--，放入res中

3：翻转输出

```cpp
class Solution {
public:
    vector<int> printNumbers(int n) {
        vector<int> res;
        string str;
        while(n--){
            str+='9';
        }
        int Num = stoi(str);
        while(Num--){
            res.push_back(Num+1);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```



#### [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

思路一：动态规划

1:首先我们想要求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的绳子转移而来

2:用一个`dp数组`记录从0到n长度的绳子剪掉后的最大乘积，也就是`dp[i]`表时长度为`i`的绳子剪成m段后的最大乘积,初始化`dp[2]=1`

3:我们把绳子剪掉第一段`（长度为j）`，如果只减去1，对最后的乘积没有任何增益，所以长度为2开始剪

4:剪了第一段后，剩下`(i-j)`长度可以不剪。如果不剪对应`j*（i-j）`;如果剪去对应`j*dp[i-j]`。取两者最大值`max(j*(i-1)，j * dp[i-j])`

5:第一段长度`j`可以取的区间为`[2)`,对所有j不同的情况取最大值，因此最终`dp[i]`的转移方程为`dp[i] = max(dp[i],j*max(dp[i-j],(i-j)))`

```cpp
class Solution {
public:
    int cuttingRope(int n) {
        if(n<2) return  0;
        vector<int> dp(n+1);//当绳子长度为i时候可能的最大乘积为dp[i]
        //确定初始化条件
        dp[2]=1;   //0跟1减没有意义
        for(int i=3;i<=n;i++){
            for(int j=2;j<i;j++){   //j表示剪下来的绳子大小，当剪下1时候没意义，所以从2开始
                //绳子有两种方式，一种是剪下之后，剩下的再剪下最大为j*dp[i-j]
                //一种是剪下之后，剩下的不减了，剩的为j*(i-j);
                dp[i] = max(dp[i],j*max(dp[i-j],(i-j)));  //里面一直跟之前的遍历减过的结果比较   
            }
        }

        return dp[n];
    }
};
```

#### [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

思路：用一个头节点,以及pre，cur双指针

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        if(head==nullptr) return head;
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* pre=dummy;
        ListNode* cur=dummy->next;
        while(cur!=nullptr){
            if(cur->val==val){
                 ListNode* next= cur->next;
                 pre->next = next;
                 cur = cur->next;
            }else{
                pre = cur;
                cur = cur->next;
            }
            
        }
        return dummy->next;
    }
};
```

#### [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

思路一：BFS广度优先遍历

1： 定义一个res返回值

2：定义一个队列，先把头节点压入队列

3：while循环判断队列是否为空不为空进入循环

4：先取出队列第一个判断左右子树为不为空，不为空就先存值到res，再往后压入队列中

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector<int> res;
        if(root==nullptr) return res;
        queue<TreeNode*> myque;
        myque.push(root);
        res.push_back(root->val);
        while(!myque.empty()){
            TreeNode* temp = myque.front();  //找到头
            myque.pop();    //弹出
            if(temp->left!=nullptr) {
             res.push_back(temp->left->val);
             myque.push(temp->left);
            }  //左不为空继续往左压
            if(temp->right!=nullptr) {
                res.push_back(temp->right->val);
                myque.push(temp->right);  //右不为空继续压
            }
        }
        return res;
    }
};
```

#### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

思路一：利用快慢双指针

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode* fast=head;
        while(k--){
            fast = fast->next;
        }

        while(fast!=nullptr){
            fast = fast->next;
            head = head->next;
        }
        return head;
    }
};
```



#### [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

思路一：用set容器，不符合题意

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        set<ListNode*> mySet;
        while(headA!=nullptr){
            mySet.insert(headA);
            headA = headA->next;
        }
        while(headB!=nullptr){
            if(mySet.find(headB)!=mySet.end()){
                return headB;
            }else{
                headB = headB->next;
            }
        }
        return nullptr;
    }
};
```

思路二：双指针

解题思路：
我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。

这样，当它们相遇时，所指向的结点就是第一个公共结点。

作者：z1m
链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/shuang-zhi-zhen-fa-lang-man-xiang-yu-by-ml-zimingm/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

我的理解： 两个链表长度分别为L1+C、L2+C， C为公共部分的长度，按照楼主的做法： 第一个人走了L1+C步后，回到第二个人起点走L2步；第2个人走了L2+C步后，回到第一个人起点走L1步。 当两个人走的步数都为L1+L2+C时就两个家伙就相爱了

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
          if (headA == nullptr || headB == nullptr) {
            return nullptr;
        }
        ListNode* node1 = headA;
        ListNode* node2 = headB;
        while(node1 !=node2 ){
            node1 = node1!=nullptr ? node1->next : headB;
            node2 = node2!=nullptr ? node2->next : headA;
        }
        return node1;
    }
};
```



#### [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

思路一：也是核心思想，就是先把句子中所有字符串取出放入字符串数组，再对数组中的字符串进行操作后重新连接即可，具体问题具体细节还需要按题目要求分析

而遍历句子取字符串的思路，就是遇到字符把它放入临时字符串，遇到空格或者标点(如果有标点)，就把临时字符串输出，并且清空

```cpp
class Solution {
public:
    string reverseWords(string s) {
        s+=' ';  //为了最后一个可以判断进入
        vector<string> vecStr;
        string tempStr,res;
        for(char c:s){
            if(c==' '){
                if(!tempStr.empty()){  //要不要判断是否为空取决于有没有前后空格
                    vecStr.push_back(tempStr);
                    tempStr.clear();
                }
            }else{
                tempStr+=c;
            }
        }

        for(int i=vecStr.size()-1;i>=0;i--){
            res +=vecStr[i];
            if(i!=0) res += ' ';
        }
        return res;
    }
};
```



#### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

思路一：二分单边 + 线性扫描

先用一次二分查找找到边界，再再边界里面寻找目标值

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int low=0;
        int high=nums.size()-1;
        int res=0;

        //判断只有一个数的情况
        // if(nums.size()==1){
        //     if(nums[0]==target){
        //         res++;
        //         return res;
        //     }
        // }

        //二分查找找到目标值所在的边界
        while(low<=high){
            int mid = (low+high)/2;
            if(nums[mid]<target){
                low = mid+1;
            }else if(nums[mid]>target){
                high = mid-1;
            }else {
                break;
            }
        }

        
        //在边界里面寻找目标值
        for(int i=low;i<=high;i++){
            if(nums[i]==target){
                 res++;
            }
        }
        return res;
    }
};
```



思路二：两次二分查找，找到左右边界，最终结果为right-left-1



#### [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)



```cpp
class Solution {
public:
    char firstUniqChar(string s) {
       unordered_map<char, int> unmap;
       for(char c:s){
           unmap[c]++;
       }

       for(char c:s){
           if(unmap[c]==1){
               return  c;
           }
       }

       return ' ';
    }
};
```



#### [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

思路一：**哈希表统计法**

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size();
        map<int, int> mymap;
        for(int num :nums){
            mymap[num]++;
        }

        for(int num:nums){
            if(mymap[num]>n/2){
                return num;
            }
        }
        return 0;
    }
};
```

思路二：摩尔投票法



#### [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

思路一：简单for循环找

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        if(nums.empty()) return 0;
        int res=nums[0];
        for(int i=0;i<nums.size();i++){
           if(nums[i]!=i){
               res = i;
               break;
           }
           res = i+1;
        }
        return res;
    }
};
```

思路二：二分法

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        if(nums.empty()) return 0;
        int low = 0,high = nums.size()-1;
        while(low<=high){
            int middel = (high+low)/2;
            if(nums[middel]==middel) low = middel+1;   //如果低位的正确，则low指针移动
            else high = middel -1;
        }
     
        return low;
    }
};
```







# 动态规划

#### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

思路一：递归

```cpp
class Solution {
public:
    int fib(int n) {
        //递归：首先确定结束条件，在写单个循环逻辑
        if(n<2) return n;
        return fib(n-1)+fib(n-2);
    }
};
```

思路二：动态规划

```cpp
class Solution {
public:
    int fib(int n) {
        //递归：首先确定结束条件，在写单个循环逻辑
        // if(n<2) return n;
        // return fib(n-1)+fib(n-2);

        /*动态规划
          第一步:确定dp数组及下标的含义
                dp[i]定义为：第i个数的斐波那契数值为dp[i]
          第二步：确定动态方程f(n)=f(n-1)+f(n-2)
          第三步：确定初始条件 f(0)=0,f(1)=1
          第四步：确定遍历顺序，从递推公式可以看出一定是从前往后遍历
          第五步：举例推到dp数组值    
        */
        if(n<2) return n;
        vector<int> dp(n+1);
        dp[0]=0;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```

动态规划优化：

```cpp
class Solution {
public:
    int fib(int n) {
        //递归：首先确定结束条件，在写单个循环逻辑
        // if(n<2) return n;
        // return fib(n-1)+fib(n-2);

        /*动态规划
          第一步:确定dp数组及下标的含义
                dp[i]定义为：第i个数的斐波那契数值为dp[i]
          第二步：确定动态方程f(n)=f(n-1)+f(n-2)
          第三步：确定初始条件 f(0)=0,f(1)=1
          第四步：确定遍历顺序，从递推公式可以看出一定是从前往后遍历
          第五步：举例推到dp数组值    
        */
        // if(n<2) return n;
        // vector<int> dp(n+1);
        // dp[0]=0;
        // dp[1]=1;
        // for(int i=2;i<=n;i++){
        //     dp[i] = dp[i-1] + dp[i-2];
        // }
        // return dp[n];

        //优化：只需要维护两个值就可以，不需要记录整个表长度
        if(n<2) return n;
        vector<int> dp(2);
        dp[0]=0;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            int sum = dp[1] + dp[0];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
};
```



#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

思路一：递归(会超时)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        //递归
        if(n==0) return 1;
        if(n<3) return n;
        return climbStairs(n-1) + climbStairs(n-2);
    }
};
```

思路二:动态规划

```cpp
class Solution {
public:
    int climbStairs(int n) {
        //递归
        // if(n==0) return 1;
        // if(n<3) return n;
        // return climbStairs(n-1) + climbStairs(n-2);
        
        //动态规划
        if(n<2) return 1;
        vector<int> dp(n+1);
        dp[0] = 1;
        dp[1] = 1;
        for(int i=2;i<=n;i++){
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
};
```

思路三：优化，不需要存全部的状态，存两个前面的状态即可

```cpp
class Solution {
public:
    int climbStairs(int n) {
        //递归
        // if(n==0) return 1;
        // if(n<3) return n;
        // return climbStairs(n-1) + climbStairs(n-2);
        
        //动态规划
        if(n<2) return 1;
        vector<int> dp(2);
        dp[0] = 1;
        dp[1] = 1;
        for(int i=2;i<=n;i++){
            int sum = dp[1]+dp[0];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
};
```



不把0初始化，因为0可以考虑就是没有这种情况无意义

以下为代码随想录的解释：

那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。

例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。

但总有点牵强的成分。

那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.

**其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1**。

从dp数组定义的角度上来说，dp[0] = 0 也能说得通。

需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。

所以本题其实就不应该讨论dp[0]的初始化！

我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。

所以我的原则是：不考虑dp[0]如果初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。

```cpp
class Solution {
public:
    int climbStairs(int n) {
        //递归
        // if(n==0) return 1;
        // if(n<3) return n;
        // return climbStairs(n-1) + climbStairs(n-2);
        
        //动态规划
        if(n<2) return n;
        vector<int> dp(3);
        dp[1] = 1;
        dp[2] = 2;
        for(int i=3;i<=n;i++){
            int sum = dp[2]+dp[1];
            dp[1] = dp[2];
            dp[2] = sum;
        }
        return dp[2];
    }
};
```



#### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

思路一：动态规划

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        if(cost.empty()) return 0;
        int n = cost.size();
        // if(n<=1) return cost[0];
        //1:确定dp数组下标含义：到达第i个楼梯的最小花费为dp[i];
        vector<int> dp(n);
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i=2;i<n;i++){
            dp[i] =cost[i] + min(dp[i-1],dp[i-2]);
        }
        //最后一步没有花费，即为上面一步或者两步花费最少的
        return min(dp[n-1],dp[n-2]);
    }
};
```

优化：存两个值即可

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        if(cost.empty()) return 0;
        int n = cost.size();
        // if(n<=1) return cost[0];
        //1:确定dp数组下标含义：到达第i个楼梯的最小花费为dp[i];
        vector<int> dp(2);
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i=2;i<n;i++){
            int sum =cost[i] + min(dp[1],dp[0]);
            dp[0] = dp[1];
            dp[1] = sum;
        }
        //最后一步没有花费，即为上面一步或者两步花费最少的
        return min(dp[1],dp[0]);
    }
};
```

#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

思路一：动态规划

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {

        //1:dp[i][j]代表到达i，j时候路径有dp[i][j]
        vector<vector<int> > dp(m,vector<int>(n,0));

        //初始化dp数组
        for(int i=0;i<m;i++) dp[i][0] = 1;
        for(int j=0;j<n;j++) dp[0][j] = 1;

        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
};
```



#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

思路一：动态规划

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m=obstacleGrid.size();
        int n=obstacleGrid[0].size();
        vector<vector<int> > dp(m,vector<int>(n,0));

        for(int i=0;i<m && obstacleGrid[i][0]==0;i++) dp[i][0] = 1;
        for(int j=0;j<n && obstacleGrid[0][j]==0;j++) dp[0][j] = 1;

        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(obstacleGrid[i][j]==1) continue;
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
};
```



#### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

思路一：动态规划

```cpp
class Solution {
public:
    int integerBreak(int n) {
        //1:dp[i]代表是：整数i拆分最大乘积为dp[i];
        //2:确定动态规划方程
        vector<int> dp(n+1); 
        dp[2] = 1;
        for(int i=3;i<=n;i++){
            for(int j=2;j<i;j++){
                dp[i] = max(dp[i],max((i-j)*j,dp[i-j]*j));
            }
        }
        
        return dp[n];
    }
};
```



#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

思路一：动态规划

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1);
        dp[0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i] +=dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
};
```



#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)



```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        //转换为01背包问题,找到整个数组sum的一半
        
        //求容器总和
        int sum = accumulate(nums.begin(),nums.end(),0);
        if(sum%2==1) return false;   //当为奇数时候不可能等分两半，所以不可能找到
        int target = sum/2;          //当为偶数时候等分，目标值为总数的一半，即背包容量

        int n = nums.size();
        // dp[i]中的i表示背包内总和
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        vector<int> dp(10001,0);//初始化

        //开始01背包
        for(int i=0;i<n;i++){
            for(int j=target;j>=nums[i];j--){
                dp[j] = max(dp[j],dp[j-nums[i]]+nums[i]);
            }
        }

        if(dp[target] == target)  return true;
        return false;

    }
};
```

#### [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = accumulate(stones.begin(), stones.end(), 0);
        int target = sum/2;

        vector<int> dp(target+1);

        //开始01背包
        for(int i=0;i<stones.size();i++){
            for(int j=target;j>=stones[i];j--){
                dp[j] = max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }

        return sum - 2*dp[target];
    }
};
```

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

思路：dp[i] = max(dp[i-2]+nums[i], dp[i-1])

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int size_n = nums.size();
        if(nums.empty()) return 0;
        if(nums.size()==1) return nums[0];

        vector<int> dp(size_n);  //定义动态数组第i个房间时候，最多的金额是dp[i]
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);
        for(int i=2;i<nums.size();i++){
            dp[i] = max(nums[i]+dp[i-2],dp[i-1]);
        }
        return dp[size_n-1];
    }
};
```

#### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

思路：考虑三种情况注释代码中

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.empty()) return 0;
        if(nums.size()==1) return nums[0];
        //考虑首端，不考虑尾端
        int value1 = robrange(nums,0,nums.size()-2);
        //考虑尾端，不考虑首端
        int value2 = robrange(nums,1,nums.size()-1);
        return max(value1,value2);
    }

    //考虑以下三种情况
    //1:不考虑首尾的情况
    //2:考虑首端情况
    //3:考虑尾端情况
    //由于情况1包含在情况2，3中，所以只要考虑后面两个即可
    int robrange(vector<int>& nums,int start,int end){
        if (end == start) return nums[start];
        vector<int> dp(nums.size(),0);  //第i个房间最高金额是dp[i]
        dp[start] = nums[start];
        dp[start+1] = max(nums[start],nums[start+1]);
        for(int i=start+2;i<=end;i++){
            dp[i] = max(nums[i]+dp[i-2],dp[i-1]);
        }
        return dp[end];
    }
};
```



#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

思路一：动态规划，暴力寻找，最大的差值，但是会超时

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int res = 0;
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                res = max(res,prices[j]-prices[i]);
            }
        }
        return res;
    }
};
```





# 滑动窗口

#### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int n = nums.size();
        int k=0;
        for(int i=0;i<n;i++){
            if(nums[i]!=val){
                nums[k] = nums[i];
                k++;
            }
        }
        return k;
    }
};
```



# [滑动窗口真滴简单!] 闪电五连鞭带你秒杀12道中档题 (附详情解析)

[EasonL4](https://leetcode-cn.com/u/eason734/)发布于 2021-07-147.9k[双指针](https://leetcode-cn.com/tag/two-pointers/)[滑动窗口](https://leetcode-cn.com/tag/sliding-window/)[Python](https://leetcode-cn.com/topic/python/)[Python3](https://leetcode-cn.com/topic/python3/)

```
最后更新时间: 2021/09/19
```

不像动态规划，绝大部分滑动窗口类题目本质上真的不算是难题，经过有效的训练就可以熟练掌握。本文中Eason给大家分享一套滑动窗口的思维框架 (共五步-五连鞭)，非常好记和容易理解。掌握它之后，你可以一口气秒杀**12道中等难度** 的同类型题目 (卧槽？12道？是的，而且给全解析，再不点赞还是人？)，从而帮助你再遇见滑动窗口类型题目的时候不再胆怯！

```
PS：在这里我就不教大家什么是滑动窗口啦，这个概念并不难，leetcode上类似的科普文也有很多，所以我就不班门弄斧了。如果读者完全没有听说过这个概念，烦请先花10分钟弄懂个大概后再来阅读本文
```

废话不多说，直接上框架 (伪代码)

```
class Solution:
    def problemName(self, s: str) -> int:
        # Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)
        x, y = ..., ...

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s)):
            # Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)
            x = new_x
            if condition:
                y = new_y

            '''
            ------------- 下面是两种情况，读者请根据题意二选1 -------------
            '''
            # Step 4 - 情况1
            # 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度 
            # 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变, 
            # 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量 
            if 窗口长度达到了限定长度:
                # 更新 (部分或所有) 维护变量 
                # 窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变

            # Step 4 - 情况2
            # 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 
            while 不合法:
                # 更新 (部分或所有) 维护变量 
                # 不断移动窗口左指针直到窗口再次合法

        # Step 5: 返回答案
        return ...
```

看不懂？ mode问题，在我们做`3. 无重复字符的最长子串`这道题前先用这个模板先套一道简单题`643. 子数组最大平均数 I `(不计算到中等题目中，基本的良心还是得有)
如果套完还不懂，不要担心，让我们再套一道，套完仍然不懂，let's 再套一道......
我们有共13 (12中1简) 道题，请相信自己，套着套着，咱们终究会弄懂的！

# 643. 子数组最大平均数 I

```
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        # Step 1
        # 定义需要维护的变量
        # 本题求最大平均值 (其实就是求最大和)，所以需要定义sum_, 同时定义一个max_avg (初始值为负无穷)
        sum_, max_avg = 0, -math.inf

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(nums)):
            # Step 3: 更新需要维护的变量 (sum_, max_avg), 不断把当前值积累到sum_上
            sum_ += nums[end]
            if end - start + 1 == k:
                max_avg = max(max_avg, sum_ / k)

            # Step 4
            # 根据题意可知窗口长度固定，所以用if
            # 窗口首指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (sum_)
            if end >= k - 1:
                sum_ -= nums[start]
                start += 1
        # Step 5: 返回答案
        return max_avg
```

现在再来让我们看看`3. 无重复字符的最长子串`这道题，你会发现其实写法也是差不多的，就是多了个哈希表然后if变成了while

# 3. 无重复字符的最长子串

```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # Step 1: 定义需要维护的变量, 本题求最大长度，所以需要定义max_len, 该题又涉及去重，因此还需要一个哈希表
        max_len, hashmap = 0, {}

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s)):
            # Step 3
            # 更新需要维护的变量 (max_len, hashmap)
            # i.e. 把窗口末端元素加入哈希表，使其频率加1，并且更新最大长度
            hashmap[s[end]] = hashmap.get(s[end], 0) + 1
            if len(hashmap) == end - start + 1:
                max_len = max(max_len, end - start + 1)
            
            # Step 4: 
            # 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 当窗口长度大于哈希表长度时候 (说明存在重复元素)，窗口不合法
            # 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)
            while end - start + 1 > len(hashmap):
                head = s[start]
                hashmap[head] -= 1
                if hashmap[head] == 0:
                    del hashmap[head]
                start += 1
        # Step 5: 返回答案 (最大长度)
        return max_len
```

没懂？没事，让我们再来做个类似的 `159. 至多包含两个不同字符的最长子串`，这道题和`3. 无重复字符的最长子串`几乎一模一样

# 159. 至多包含两个不同字符的最长子串

```
class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
        # Step 1: 
        # 定义需要维护的变量, 本题求最大长度，所以需要定义max_len,
        # 该题又涉及计算不重复元素个数，因此还需要一个哈希表
        max_len, hashmap = 0, {}

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s)):
            # Step 3
            # 更新需要维护的变量 (max_len, hashmap)
            # 首先，把当前元素的计数加一
            # 一旦哈希表长度小于等于2(之多包含2个不同元素)，尝试更新最大长度
            tail = s[end]
            hashmap[tail] = hashmap.get(tail, 0) + 1
            if len(hashmap) <= 2:
                max_len = max(max_len, end - start + 1)

            # Step 4: 
            # 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 哈希表长度大于2的时候 (说明存在至少3个重复元素)，窗口不合法
            # 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)
            while len(hashmap) > 2:
                head = s[start]
                hashmap[head] -= 1
                if hashmap[head] == 0:
                    del hashmap[head]
                start += 1
        # Step 5: 返回答案 (最大长度)
        return max_len
```

还是没有什么感觉? 没问题，再来一道

# 209. 长度最小的子数组

```
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        # Step 1: 定义需要维护的变量, 本题求最小长度，所以需要定义min_len, 本题又涉及求和，因此还需要一个sum变量
        min_len, sum_ = math.inf, 0

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(nums)):
            # Step 3: 更新需要维护的变量 (min_len, sum_)
            sum_ += nums[end]

            # 这一段可以删除，因为下面的while已经handle了这一块儿逻辑，不过写在这也没影响
            if sum_ >= target:
                min_len = min(min_len, end - start + 1)

            # Step 4
            # 这一题这里稍微有一点特别: sum_ >= target其实是合法的，但由于我们要求的是最小长度，
            # 所以当sum_已经大于target的时候继续移动右指针没有意义，因此还是需要移动左指针慢慢逼近答案
            # 由于左指针的移动可能影响min_len和sum_的值，因此需要在移动前将它们更新
            while sum_ >= target:
                min_len = min(min_len, end - start + 1)
                sum_ -= nums[start]
                start += 1
        # Step 5：返回答案 (最小长度)
        if min_len == math.inf:
            return 0
        return min_len
```

没有看懂? 没问题，没问题, 再来一道

# 1695. 删除子数组的最大得分

```
class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        # Step 1
        # 定义需要维护的变量, 本题最大得分，所以需要定义当前得分sum_和最大得分max_sum
        # 本题又涉及去重 (题目规定子数组不能有重复)，因此还需要一个哈希表
        sum_, max_sum, hashmap = 0, 0, {}

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(nums)):
            # Step 3
            # 更新需要维护的变量 (sum_, hashmap)
            # sum和hashmap需要更新就不说了，max_sum当且仅当哈希表里面没有重复元素时 (end - start + 1 == len(hashmap)) 更新
            tail = nums[end]
            sum_ += tail
            hashmap[tail] = hashmap.get(tail, 0) + 1
            if end - start + 1 == len(hashmap):
                max_sum = max(max_sum, sum_)
            
            # Step 4
            # 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 哈希表里面有重复元素时 (end - start + 1 > len(hashmap)) 窗口不合法
            # 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap， sum_)
            while end - start + 1 > len(hashmap):
                head = nums[start]
                hashmap[head] -= 1
                if hashmap[head] == 0:
                    del hashmap[head]
                sum_ -= nums[start]
                start += 1
        # Step 5: 返回答案
        return max_sum
```

依旧没完全懂? 没问题，没问题, 没问题, 再来一道!

# 438. 找到字符串中所有字母异位词

```
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        # Step 1: 
        # 定义需要维护的变量
        # 本文需要对比两组字符串是否为异位词，所以用哈希表 (abc和bac是异位词是因为他们对应的哈希表相等)
        # 同时我们需要找到所有合法解，所以还需要一个res数组
        res, hashmap = [], {}

        # Step 1.1： 同时把p的哈希表也建立了 (这个哈希表不需要维护，为定值)
        hashmap_p = {}
        for char in p:
            hashmap_p[char] = hashmap_p.get(char, 0) + 1

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s)):
            # Step 3: 更新需要维护的变量 (hashmap)， 如果hashmap == hashmap_p，代表找到了一个解，加入到res
            hashmap[s[end]] = hashmap.get(s[end], 0) + 1
            if hashmap == hashmap_p:
                res.append(start)

            # Step 4 
            # 根据题意可知窗口长度固定，所以用if
            # 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (hashmap)
            if end >= len(p) - 1:
                hashmap[s[start]] -= 1
                if hashmap[s[start]] == 0:
                    del hashmap[s[start]]
                start += 1
        # Step 5: 返回答案
        return res
```

再来一题！

# 567. 字符串的排列

```
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        # Step 1
        # 定义需要维护的变量
        # 因为和排列相关 (元素相同，顺序可以不同)，使用哈希表
        hashmap2 = {}

        # Step 1.1: 同时建立s1的哈希表 (这个哈希表不需要维护，为定值)
        hashmap1 = {}
        for char in s1:
            hashmap1[char] = hashmap1.get(char, 0) + 1
        
        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s2)):
            # Step 3: 更新需要维护的变量 (hashmap2)， 如果hashmap1 == hashmap2，代表s2包含s1的排列，直接return
            tail = s2[end]
            hashmap2[tail] = hashmap2.get(tail, 0) + 1
            if hashmap1 == hashmap2:
                    return True

            # Step 4: 
            # 根据题意可知窗口长度固定，所以用if
            # 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (hashmap2)
            if end >= len(s1) - 1:
                head = s2[start]
                hashmap2[head] -= 1
                if hashmap2[head] == 0:
                    del hashmap2[head]
                start += 1
        # Step 5： 没有在s2中找到s1的排列，返回False
        return False
```

再再来一题 (声音开始颤抖)！

# 487. 最大连续1的个数 II

```
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        # Step 1
        # 定义需要维护的变量
        # 因为是求最大长度，所以有max_len，又同时涉及计数 (0的个数不能超过1个)，所以还要一个哈希表
        max_len, hashmap = 0, {}

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(nums)):
            # Step 3: 更新需要维护的变量 (hashmap， max_len)
            tail = nums[end]
            hashmap[tail] = hashmap.get(tail, 0) + 1
            if hashmap.get(0, 0) <= 1:
                max_len = max(max_len, end - start + 1)

            # Step 4
            # 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 当hashmap里面0的个数大于1的时候，窗口不合法
            # 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)
            while hashmap.get(0, 0) > 1:
                head = nums[start]
                hashmap[head] -= 1
                start += 1
        # Step 5: 返回答案 (最大长度)
        return max_len
```

再再再来一题 (声音变得沙哑)！下面一题是上面一题的变种，运用该模板，只需要改**一个**参数

# 1004. 最大连续1的个数 III

```
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        max_len, hashmap = 0, {}

        start =  0
        for end in range(len(nums)):
            tail = nums[end]
            hashmap[tail] = hashmap.get(tail, 0) + 1
            if hashmap.get(0, 0) <= k:
                max_len = max(max_len, end - start + 1)

            # 相比较于上一题，只需要把1改成k
            while hashmap.get(0, 0) > k:
                head = nums[start]
                hashmap[head] -= 1
                start += 1
        return max_len
```

`[再 for i in range(4)]`来一题！ (已经接近失声)

# 1208. 尽可能使字符串相等

```
class Solution:
    def equalSubstring(self, s: str, t: str, max_cost: int) -> int:
        # Step 1: 定义需要维护的变量
        # 因为是求最大长度，所以有max_len，又同时涉及计算开销 (和求和一个道理)， 所以还要一个cur_cost
        cur_cost, max_len = 0, 0
        
        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(t)):
            # Step 3
            # 更新需要维护的变量 (cur_cost)
            # 每一对字符的order差值就是当前时间点的开销，直接累积在cur_cost上即可
            # cur_cost只要不超过最大开销，就更新max_len
            cur_cost += abs(ord(s[end]) - ord(t[end]))
            if cur_cost <= max_cost:
                max_len = max(max_len, end - start + 1)

            # Step 4
            # 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 当cur_cost大于最大开销时候，窗口不合法
            # 所以需要不断移动窗口左指针直到窗口再次合法 (cur_cost <= max_cost)
            while cur_cost > max_cost:
                cur_cost -= abs(ord(s[start])-  ord(t[start]))
                start += 1
        # Step 5: 返回答案 (最大长度)
        return max_len
```

再..........咳咳

# 1052. 爱生气的书店老板

```
class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
        # Step 1
        # 定义需要维护的变量,
        # 因为涉及求和所以定义sum_和max_sum, 同时需要知道老板什么时候'发动技能'，再定义一个max_start
        sum_, max_sum, max_start = 0, 0, 0
  
        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(customers)):
            # Step 3
            # 更新需要维护的变量 (sum_)
            # 注意：这里只要当老板在当前时间点会发脾气的时候才维护
            # sum_就不说了，和前面N道题的维护方法一样，新多出来的max_start也就是记录一样时间点而已，没什么fancy的
            if grumpy[end] == 1:
                sum_ += customers[end]
            if sum_ > max_sum:
                max_sum = sum_
                max_start = start

            # Step 4
            # 根据题意可知窗口长度固定 (老板技能持续时间固定)，所以用if
            # 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (sum_, max_avg)
            if end >= minutes - 1:
                if grumpy[start]:
                    sum_ -= customers[start]
                start += 1

        # 这里对比其他题目多了一小步: 在找到老板发动技能的最大收益时间点(max_start)后
        # 需要把受技能影响时间段中的grumpy全部置0 - 代表老板成功压制了自己的怒火
        for i in range(max_start, max_start + minutes):
            grumpy[i] = 0

        # Step 5: 再遍历一遍数组求customer总数量并且返回结果
        res = 0
        for i in range(len(customers)):
            if not grumpy[i]:
                res += customers[i]
        return res
```

一片寂静......

# 1423. 可获得的最大点数

```
class Solution:
    # 这题相比前面的题目加了一丢丢小的变通: 题目要求首尾串最大点数，其实就是求非首尾串的连续序列的最小点数
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        # 特解
        n = len(cardPoints)
        if k == n:
            return sum(cardPoints)

        # Step 1
        # 定义需要维护的变量，因为涉及求和所以定义sum_和min_sum
        m = n - k
        sum_, min_sum = 0, math.inf

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(n):
            # Step 3
            # 更新需要维护的变量 (sum_)
            sum_ += cardPoints[end]

            # Step 4
            # 根据题意可知窗口长度固定，所以用if
            # 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (min_sum， sum_)
            if end >= m - 1:
                min_sum = min(min_sum, sum_)
                sum_ -= cardPoints[start]
                start += 1
        # Step 5: 返回答案 (总点数减去非首尾串的连续序列的最小点数就可以得到首尾串的最大点数)
        return sum(cardPoints) - min_sum
```

# 1151. 最少交换次数来组合所有的 1

```
class Solution:
    def minSwaps(self, data: List[int]) -> int:
        # 先数出一共有多少个1，输出来的个数就是窗口的长度
        num_ones = 0
        for i in range(len(data)):
            if data[i] == 1:
                num_ones += 1

        # Step 1
        # 定义需要维护的变量，求最小swap次数其实就是求窗口中0个数的最小值，因此定义num_zeros, min_num_zeros
        num_zeros, min_num_zeros = 0, math.inf

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(data)):
            # Step 3
            # 更新需要维护的变量 (num_zeros， min_num_zeros)
            if data[end] == 0:
                num_zeros += 1
            if end - start + 1 == num_ones:
                min_num_zeros = min(min_num_zeros, num_zeros)

            # Step 4
            # 根据题意可知窗口长度固定 (数组1的总个数)，所以用if
            # 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (num_zeros)
            if end >= num_ones - 1:
                if data[start] == 0:
                    num_zeros -= 1
                start += 1
        
        # Step 5: 返回答案 (如果min_num_zeros依旧是math.inf说明数组没有1存在，不能swap，返回0即可)
        if min_num_zeros == math.inf:
            return 0
        return min_num_zeros
```

OK......到目前为止，12道中等题全部结束。读者到此应该可以感觉到这12道题目其实就是遵循一个模子，沿用楼主share的思路只需要修改个别变量就可以全部秒杀！当然，模板只是对思路进行浓缩，楼主不建议大家硬背模板，而是建议先结合模板和几道样题，通过笔纸反复模拟出窗口的滑动过程去加深理解滑动窗口类型题目的共通之处。

Eason在此祝愿大家今后在面试遇见同类型的题目可以直接秒杀，如果看官觉得本文有帮助，希望可以三连以示鼓励！











# 9.25刷题 字符串判断

#### [58. 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)



```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        s+=' '; //为了让最后一个数进入循环判断
        string tempStr;
        vector<string> res;
        for(char c:s){
            if(c==' '){
                if(!tempStr.empty()){
                    res.push_back(tempStr);
                    tempStr.clear();
                }
            }else {
                tempStr+=c;
            }
        }

        int num = res.back().size();
        return num;
    }
};
```



#### [557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

```cpp
class Solution {
public:
    string reverseWords(string s) {

        s+=' '; //为了让最后一个单词进入循环
        string tempstr,res;
        vector<string> vecstr;
        for(char c:s){
            if(c==' '){
                reverse(tempstr.begin(), tempstr.end());
                vecstr.push_back(tempstr);
                tempstr.clear();
            }else {
                tempstr+=c;
            }
        }
        
        for(int i=0;i<vecstr.size();i++){
            res+=vecstr[i];
            res+=' ';
        }
        res.pop_back();   //去除最后一个空格
        return res;
    }
};
```



优化

```cpp
class Solution {
public:
    string reverseWords(string s) {
        s+=' '; //为了让最后一个单词进入循环
        string tempstr,res;
        for(char c:s){
            if(c==' '){
                reverse(tempstr.begin(), tempstr.end());
                res+=tempstr;
                res+=' ';
                tempstr.clear();
            }else {
                tempstr+=c;
            }
        }
        res.pop_back();   //去除最后一个空格
        return res;
    }
};
```

